// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AuthFaiulreTearOff {
  const _$AuthFaiulreTearOff();

  ServerAuthError serverAuthError() {
    return const ServerAuthError();
  }

  InvalidEmailOrPasssword invalidEmailOrPasssword() {
    return const InvalidEmailOrPasssword();
  }

  EmailAlreadyInUse emailAlreadyInUse() {
    return const EmailAlreadyInUse();
  }

  NetworkFailedError networkError() {
    return const NetworkFailedError();
  }

  WriteToLocalError writeToLocalError() {
    return const WriteToLocalError();
  }

  ReadFromLocalError readFromLocalError() {
    return const ReadFromLocalError();
  }

  InvalidValue invalidValue() {
    return const InvalidValue();
  }
}

/// @nodoc
const $AuthFaiulre = _$AuthFaiulreTearOff();

/// @nodoc
mixin _$AuthFaiulre {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFaiulreCopyWith<$Res> {
  factory $AuthFaiulreCopyWith(
          AuthFaiulre value, $Res Function(AuthFaiulre) then) =
      _$AuthFaiulreCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFaiulreCopyWithImpl<$Res> implements $AuthFaiulreCopyWith<$Res> {
  _$AuthFaiulreCopyWithImpl(this._value, this._then);

  final AuthFaiulre _value;
  // ignore: unused_field
  final $Res Function(AuthFaiulre) _then;
}

/// @nodoc
abstract class $ServerAuthErrorCopyWith<$Res> {
  factory $ServerAuthErrorCopyWith(
          ServerAuthError value, $Res Function(ServerAuthError) then) =
      _$ServerAuthErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ServerAuthErrorCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $ServerAuthErrorCopyWith<$Res> {
  _$ServerAuthErrorCopyWithImpl(
      ServerAuthError _value, $Res Function(ServerAuthError) _then)
      : super(_value, (v) => _then(v as ServerAuthError));

  @override
  ServerAuthError get _value => super._value as ServerAuthError;
}

/// @nodoc

class _$ServerAuthError implements ServerAuthError {
  const _$ServerAuthError();

  @override
  String toString() {
    return 'AuthFaiulre.serverAuthError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ServerAuthError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return serverAuthError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (serverAuthError != null) {
      return serverAuthError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return serverAuthError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (serverAuthError != null) {
      return serverAuthError(this);
    }
    return orElse();
  }
}

abstract class ServerAuthError implements AuthFaiulre {
  const factory ServerAuthError() = _$ServerAuthError;
}

/// @nodoc
abstract class $InvalidEmailOrPassswordCopyWith<$Res> {
  factory $InvalidEmailOrPassswordCopyWith(InvalidEmailOrPasssword value,
          $Res Function(InvalidEmailOrPasssword) then) =
      _$InvalidEmailOrPassswordCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidEmailOrPassswordCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $InvalidEmailOrPassswordCopyWith<$Res> {
  _$InvalidEmailOrPassswordCopyWithImpl(InvalidEmailOrPasssword _value,
      $Res Function(InvalidEmailOrPasssword) _then)
      : super(_value, (v) => _then(v as InvalidEmailOrPasssword));

  @override
  InvalidEmailOrPasssword get _value => super._value as InvalidEmailOrPasssword;
}

/// @nodoc

class _$InvalidEmailOrPasssword implements InvalidEmailOrPasssword {
  const _$InvalidEmailOrPasssword();

  @override
  String toString() {
    return 'AuthFaiulre.invalidEmailOrPasssword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailOrPasssword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return invalidEmailOrPasssword();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (invalidEmailOrPasssword != null) {
      return invalidEmailOrPasssword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return invalidEmailOrPasssword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (invalidEmailOrPasssword != null) {
      return invalidEmailOrPasssword(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailOrPasssword implements AuthFaiulre {
  const factory InvalidEmailOrPasssword() = _$InvalidEmailOrPasssword;
}

/// @nodoc
abstract class $EmailAlreadyInUseCopyWith<$Res> {
  factory $EmailAlreadyInUseCopyWith(
          EmailAlreadyInUse value, $Res Function(EmailAlreadyInUse) then) =
      _$EmailAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $EmailAlreadyInUseCopyWith<$Res> {
  _$EmailAlreadyInUseCopyWithImpl(
      EmailAlreadyInUse _value, $Res Function(EmailAlreadyInUse) _then)
      : super(_value, (v) => _then(v as EmailAlreadyInUse));

  @override
  EmailAlreadyInUse get _value => super._value as EmailAlreadyInUse;
}

/// @nodoc

class _$EmailAlreadyInUse implements EmailAlreadyInUse {
  const _$EmailAlreadyInUse();

  @override
  String toString() {
    return 'AuthFaiulre.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class EmailAlreadyInUse implements AuthFaiulre {
  const factory EmailAlreadyInUse() = _$EmailAlreadyInUse;
}

/// @nodoc
abstract class $NetworkFailedErrorCopyWith<$Res> {
  factory $NetworkFailedErrorCopyWith(
          NetworkFailedError value, $Res Function(NetworkFailedError) then) =
      _$NetworkFailedErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$NetworkFailedErrorCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $NetworkFailedErrorCopyWith<$Res> {
  _$NetworkFailedErrorCopyWithImpl(
      NetworkFailedError _value, $Res Function(NetworkFailedError) _then)
      : super(_value, (v) => _then(v as NetworkFailedError));

  @override
  NetworkFailedError get _value => super._value as NetworkFailedError;
}

/// @nodoc

class _$NetworkFailedError implements NetworkFailedError {
  const _$NetworkFailedError();

  @override
  String toString() {
    return 'AuthFaiulre.networkError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NetworkFailedError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return networkError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return networkError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(this);
    }
    return orElse();
  }
}

abstract class NetworkFailedError implements AuthFaiulre {
  const factory NetworkFailedError() = _$NetworkFailedError;
}

/// @nodoc
abstract class $WriteToLocalErrorCopyWith<$Res> {
  factory $WriteToLocalErrorCopyWith(
          WriteToLocalError value, $Res Function(WriteToLocalError) then) =
      _$WriteToLocalErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$WriteToLocalErrorCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $WriteToLocalErrorCopyWith<$Res> {
  _$WriteToLocalErrorCopyWithImpl(
      WriteToLocalError _value, $Res Function(WriteToLocalError) _then)
      : super(_value, (v) => _then(v as WriteToLocalError));

  @override
  WriteToLocalError get _value => super._value as WriteToLocalError;
}

/// @nodoc

class _$WriteToLocalError implements WriteToLocalError {
  const _$WriteToLocalError();

  @override
  String toString() {
    return 'AuthFaiulre.writeToLocalError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WriteToLocalError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return writeToLocalError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (writeToLocalError != null) {
      return writeToLocalError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return writeToLocalError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (writeToLocalError != null) {
      return writeToLocalError(this);
    }
    return orElse();
  }
}

abstract class WriteToLocalError implements AuthFaiulre {
  const factory WriteToLocalError() = _$WriteToLocalError;
}

/// @nodoc
abstract class $ReadFromLocalErrorCopyWith<$Res> {
  factory $ReadFromLocalErrorCopyWith(
          ReadFromLocalError value, $Res Function(ReadFromLocalError) then) =
      _$ReadFromLocalErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$ReadFromLocalErrorCopyWithImpl<$Res>
    extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $ReadFromLocalErrorCopyWith<$Res> {
  _$ReadFromLocalErrorCopyWithImpl(
      ReadFromLocalError _value, $Res Function(ReadFromLocalError) _then)
      : super(_value, (v) => _then(v as ReadFromLocalError));

  @override
  ReadFromLocalError get _value => super._value as ReadFromLocalError;
}

/// @nodoc

class _$ReadFromLocalError implements ReadFromLocalError {
  const _$ReadFromLocalError();

  @override
  String toString() {
    return 'AuthFaiulre.readFromLocalError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ReadFromLocalError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return readFromLocalError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (readFromLocalError != null) {
      return readFromLocalError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return readFromLocalError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (readFromLocalError != null) {
      return readFromLocalError(this);
    }
    return orElse();
  }
}

abstract class ReadFromLocalError implements AuthFaiulre {
  const factory ReadFromLocalError() = _$ReadFromLocalError;
}

/// @nodoc
abstract class $InvalidValueCopyWith<$Res> {
  factory $InvalidValueCopyWith(
          InvalidValue value, $Res Function(InvalidValue) then) =
      _$InvalidValueCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidValueCopyWithImpl<$Res> extends _$AuthFaiulreCopyWithImpl<$Res>
    implements $InvalidValueCopyWith<$Res> {
  _$InvalidValueCopyWithImpl(
      InvalidValue _value, $Res Function(InvalidValue) _then)
      : super(_value, (v) => _then(v as InvalidValue));

  @override
  InvalidValue get _value => super._value as InvalidValue;
}

/// @nodoc

class _$InvalidValue implements InvalidValue {
  const _$InvalidValue();

  @override
  String toString() {
    return 'AuthFaiulre.invalidValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidValue);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() serverAuthError,
    required TResult Function() invalidEmailOrPasssword,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() networkError,
    required TResult Function() writeToLocalError,
    required TResult Function() readFromLocalError,
    required TResult Function() invalidValue,
  }) {
    return invalidValue();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? serverAuthError,
    TResult Function()? invalidEmailOrPasssword,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? networkError,
    TResult Function()? writeToLocalError,
    TResult Function()? readFromLocalError,
    TResult Function()? invalidValue,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ServerAuthError value) serverAuthError,
    required TResult Function(InvalidEmailOrPasssword value)
        invalidEmailOrPasssword,
    required TResult Function(EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(NetworkFailedError value) networkError,
    required TResult Function(WriteToLocalError value) writeToLocalError,
    required TResult Function(ReadFromLocalError value) readFromLocalError,
    required TResult Function(InvalidValue value) invalidValue,
  }) {
    return invalidValue(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ServerAuthError value)? serverAuthError,
    TResult Function(InvalidEmailOrPasssword value)? invalidEmailOrPasssword,
    TResult Function(EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(NetworkFailedError value)? networkError,
    TResult Function(WriteToLocalError value)? writeToLocalError,
    TResult Function(ReadFromLocalError value)? readFromLocalError,
    TResult Function(InvalidValue value)? invalidValue,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue(this);
    }
    return orElse();
  }
}

abstract class InvalidValue implements AuthFaiulre {
  const factory InvalidValue() = _$InvalidValue;
}
